from base64 import b64decode
import copy
from datetime import timedelta, datetime
import hashlib
import json
import os
import uuid
import libnacl.public
import pgpy
import tempdir
import unittest2

from main.utils import gpg_encrypt, gpg_decrypt, generate_public_elgamal_key, update_private_elgamal_key, \
    apply_certificates, MultiElGamalWithRecovery
from trustee.utils import int_b64decode
from trustee.process_message import process_message

# set up django
# this allows main.utils to work
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tce_server.settings')
import django
django.setup()


class TestOfflineProcessor(unittest2.TestCase):
    """
        Test trustee message processing.
    """

    @classmethod
    def setUpClass(cls):
        # set up the shared parameters

        # generated by `openssl dhparam -out dh4096.pem 4096`
        cls.p = 921355984572641311672343424898410239406765173564481049529310998437412969038866770004018133863821119723063474210217706973316313378613043770818780115988652746380714841456142639704626352778746695851788302212813071729066781855064705915608677688092341542568424482925462180633889723579377448564293509252435087477281161286147259728549498972138533165527662691306617571151999644107722686129055657829181973528055808318168063541650472028439642172128232391355303186171522887793994216888734434516097403106470551045418225907760866937899119453358993949368302899196593348587781289829114461181435009345801458736138423284445935647778071510107564961338155282235194713303681529865383261800265733083885319259454542964149249843475773904339566680218460878240048849309064731923166303421897726591880342754670170435647389065546266133258192653962148274540863521430747245658342533592543361748499215018089153994702237916350245910933537662925365405565771274120172582583500547352310022433066022690275959677696743489993411404619219133001998952984404232404962367594198986426803887303895347014868878166590277345633941382072502883955197749732581385414098128645307956625290745193548601504669931868639779915942610143766629826114677053173092959998726060927521195420788443

        # smallest value passing the tests in https://github.com/dlitz/pycrypto/blob/master/lib/Crypto/PublicKey/ElGamal.py#L161
        cls.g = 5

        cls.mg = MultiElGamalWithRecovery(p=cls.p, g=cls.g)

        # set up the trustees
        cls.trustees = []
        for i in range(3):
            trustee = {}
            trustee['temp_dir'] = tempdir.TempDir()
            trustee['settings'] = {
                'p': cls.p,
                'g': cls.g,
                'private_signing_key': open(os.path.join(os.path.dirname(__file__), 'files/trustee_%s_private_key.asc' % (i+1))).read(),
                'contract_private_key_dir': trustee['temp_dir'].name,
            }
            cls.trustees.append(trustee)

        # set up a new key
        cls.key_id = str(uuid.uuid4())
        cls.contract = {
            'release_date': (datetime.utcnow() + timedelta(0,60)).isoformat(),
            'recovery_threshold': 2,
            'share_count': 3,
        }

        # run first round
        cls.first_round_message = {
            'uuid': cls.key_id,
            'action': 'generate_contract_keypair'
        }
        cls.first_round_responses = [process_message(cls.first_round_message, trustee['settings']) for trustee in cls.trustees]

        # run second round
        cls.second_round_message = {
            'uuid': cls.key_id,
            'action': 'generate_share',
            'contract_public_keys': [response['contract_public_key'] for response in cls.first_round_responses],
            'recovery_threshold': cls.contract['recovery_threshold'],
        }
        cls.second_round_responses = [process_message(cls.second_round_message, trustee['settings']) for trustee in cls.trustees]

        # run third round
        cls.state = {
            'uuid': cls.key_id,
            'contract': cls.contract,
            'shares': [response['share'] for response in cls.second_round_responses],
        }
        cls.state_json = json.dumps(cls.state)
        identity = "Time capsule key for %s (%s)" % (cls.contract['release_date'], json.dumps({
            'uuid': cls.key_id,
            'contract': cls.contract,
            'state_digest': hashlib.sha256(cls.state_json).hexdigest()
        }))
        cls.y = cls.mg.combine_public_keys(int_b64decode(response['share']['y']) for response in cls.second_round_responses)
        cls.public_gpg_key, temp_private_gpg_key = generate_public_elgamal_key(cls.p, cls.g, cls.y, identity)
        cls.third_round_message = {
            'uuid': cls.key_id,
            'action': 'validate_combined_key',
            'state': cls.state_json,
            'combined_gpg_key': cls.public_gpg_key,
        }
        cls.third_round_responses = [process_message(cls.third_round_message, trustee['settings']) for trustee in cls.trustees]

        # create signed public key
        certs = [pgpy.PGPSignature.from_blob(response['certificate']) for response in cls.third_round_responses]
        cls.signed_gpg_key = apply_certificates(cls.public_gpg_key, certs)

        # recover private key
        cls.contract_private_keys = [open(os.path.join(trustee['settings']['contract_private_key_dir'], cls.key_id)).read() for trustee in cls.trustees]
        cls.decrypted_state = copy.deepcopy(cls.state)
        for share in cls.decrypted_state['shares']:
            share['x'] = int_b64decode(cls.decrypt(share['x'], share['contract_public_key'], cls.contract_private_keys))
            share['subshares'] = [int_b64decode(cls.decrypt(subshare, share['contract_public_key'], cls.contract_private_keys)) for subshare in share['subshares']]
        recovery_shares = [[share['x'], list(enumerate(share['subshares'], start=1))] for share in cls.decrypted_state['shares']]
        cls.recovered_x = cls.mg.recover_private_key(cls.y, recovery_shares, cls.contract['recovery_threshold'])
        cls.private_gpg_key = update_private_elgamal_key(temp_private_gpg_key, cls.recovered_x)


    @classmethod
    def tearDownClass(cls):
        for trustee in cls.trustees:
            trustee['temp_dir'].dissolve()

    @staticmethod
    def decrypt(message, from_key, candidate_keys):
        for to_key in candidate_keys:
            try:
                return libnacl.public.Box(b64decode(to_key), b64decode(from_key)).decrypt(b64decode(message))
            except ValueError:
                continue
        raise ValueError("No valid decryption key found.")

    ### test generated keys ###

    def test_gpg_keys_work(self):
        message = "This is a test."
        self.assertEqual(message, gpg_decrypt(self.private_gpg_key, gpg_encrypt(self.public_gpg_key, message)))

    def test_gpg_params(self):
        private_key, _ = pgpy.PGPKey.from_blob(self.private_gpg_key)
        self.assertEqual(len(private_key.subkeys), 1)
        elgamal_subkey = private_key.subkeys[private_key.subkeys.keys()[0]]
        elgamal_keymaterial = elgamal_subkey._key.keymaterial
        self.assertEqual(elgamal_subkey.key_algorithm.name, 'ElGamal')
        self.assertEqual(elgamal_keymaterial.p, self.p)
        self.assertEqual(elgamal_keymaterial.g, self.g)
        self.assertEqual(elgamal_keymaterial.y, self.y)
        self.assertEqual(elgamal_keymaterial.x, self.recovered_x)
